#!/usr/bin/env python3

import os
import argparse
import pathlib
import vitis
import re
from typing import List, Dict
import xml.etree.ElementTree as ElementTree


class StateInfo:
    def __init__(self, state_id: int):
        self.id = state_id
        self.instructions = []
        self.module = None


class ModuleInfo:
    modules: Dict[str, "ModuleInfo"] = {}

    def __init__(self, module_name):
        self.module_name = module_name

        self.optimized_function = None
        self.debug_function = None

        self.state_infos: Dict[int, StateInfo] = {}


class InstanceInfo:
    def __init__(self, module_name, instance_name):
        self.module_name = module_name
        self.instance_name = instance_name

        if module_name not in ModuleInfo.modules:
            ModuleInfo.modules[module_name] = ModuleInfo(module_name)
        self.module_info = ModuleInfo.modules[module_name]


class DesignInfo:
    def __init__(self, solution):
        self.__solution = solution
        self.__parse_design_xml()
        self.top_name = ""

    def __parse_design_xml(self):
        xml_files = list(pathlib.Path(self.__solution).rglob("*.design.xml"))
        assert len(xml_files) == 1, "Only one design allowed in the solution"
        xml_file = xml_files[0]
        # parse the xml file to build design hierarchy
        # also set the top name
        filename = os.path.basename(xml_file)
        self.top_name = filename.replace(".design.xml", "")
        tree = ElementTree.parse(xml_file)
        root = tree.getroot()
        top_module = root.find("./RTLDesignHierarchy/TopModule")
        top_module_name = top_module.find("ModuleName").text
        assert top_module_name == self.top_name, "Design database files corrupted"
        # recursively figure out the design hierarchy
        self.design_hierarchy: Dict[str, List[InstanceInfo]] = {}
        # create top module
        ModuleInfo.modules[top_module_name] = ModuleInfo(top_module_name)
        self.__build_instance_hierarchy(top_module_name, top_module)
        self.__parse_llvm_bc()
        self.__parse_state_transition(self.top_name)
        self.__compute_variable_mapping()

    def __build_instance_hierarchy(self, parent_name, node):
        inst_list = node.find("InstancesList")
        self.design_hierarchy[parent_name] = []
        if inst_list is None:
            return
        for child in inst_list.findall("Instance"):
            inst_name = child.find("InstName").text
            module_name = child.find("ModuleName").text
            self.design_hierarchy[parent_name].append(InstanceInfo(module_name, inst_name))
            # recursive call
            self.__build_instance_hierarchy(module_name, child)

    def __parse_llvm_bc(self):
        # find the nice build with all the debug information
        g_bc_filename = os.path.join(self.__solution, ".autopilot", "db", self.top_name + ".bc")
        o3_filename = os.path.join(self.__solution, ".autopilot", "db", "a.o.3.bc")
        assert os.path.exists(g_bc_filename) and os.path.exists(o3_filename), "Design bitcode not found"
        self.__g_bc = vitis.parse_llvm_bitcode(g_bc_filename)
        self.__o3_bc = vitis.parse_llvm_bitcode(o3_filename)

        # read out the debug build and figure out the call graph
        top_function = self.__g_bc.get_function(self.top_name)
        optimized_top_function = self.__o3_bc.get_function(self.top_name)
        assert top_function is not None and optimized_top_function is not None, \
            "Unable to locate top function in LLVM bitcode"
        # we need to index locations to function instruction so that once we look at the state transition
        # we know what function to look at
        self.__loc_map = top_function.get_instr_loc()
        g_function_names = top_function.get_contained_functions()
        # need to establish mapping from the debug build to the optimized build
        # notice that we don't know the logic of how labeled basic block gets transformed into a function inside
        # Vitis (it's not open-sourced). As a result, we have to get creative
        self.__optimized_function_mapping = self.__o3_bc.get_optimized_functions(g_function_names)
        self.__optimized_function_mapping[self.top_name] = optimized_top_function
        # need to compute the demangled name, which is the instance name
        for name, func in self.__optimized_function_mapping.items():
            module_name = func.demangled_name
            assert module_name in ModuleInfo.modules
            ModuleInfo.modules[module_name].optimized_function = func
            ModuleInfo.modules[module_name].debug_function = self.__g_bc.get_function(name)

    def __parse_state_transition(self, module_name):
        # we need to parse state transition for every module since they are independent

        # recursively parse the state transition
        instances = self.design_hierarchy[module_name]
        for inst in instances:
            m_name = inst.module_name
            # recursively parse it
            self.__parse_state_transition(m_name)

        module_state_info = ModuleInfo.modules[module_name].state_infos
        rpt_path = os.path.join(self.__solution, ".autopilot", "db", module_name + ".verbose.rpt")
        assert os.path.exists(rpt_path), "Unable to find top verbose report"
        with open(rpt_path, "r") as f:
            rpt_lines = f.readlines()
        for i, line in enumerate(rpt_lines):
            if line.strip() == "* FSM state operations:":
                rpt_lines = rpt_lines[i + 1:]
                break
        for i, line in enumerate(rpt_lines):
            line = line.strip()
            if line and line[0] == "=":
                rpt_lines = rpt_lines[:i]
                break
        current_state = None
        state_num_re = re.compile(r"State(?P<id>\s\d+)")
        state_instr_re = re.compile(
            r"ST_\d+\s+:\s+[\w\s\[\]()/\.]+--->\s+\"(?P<instr>[\w%_\s=@\.,]+)\"\s+(\[(?P<debug>.*)])?\s+--->")
        for line in rpt_lines:
            m = state_num_re.search(line)
            if m is not None:
                state_id = m.group("id")
                if state_id:
                    state_id = int(state_id)
                    current_state = StateInfo(state_id)
                    module_state_info[state_id] = current_state
                    continue
            else:
                m = state_instr_re.search(line)
                if m is not None:
                    instr = m.group("instr")
                    debug = m.group("debug")
                    if debug is not None:
                        line_idx = debug.rindex(":")
                        filename = debug[:line_idx]
                        line_num = int(debug[line_idx + 1:])
                        debug = (filename, line_num)
                    current_state.instructions.append((instr, debug))

        # match state with module
        for state_id, state_info in module_state_info.items():
            instrs = self.__get_state_related_instr(module_name, state_id)
            if len(instrs) == 0:
                continue
            # use the first one
            instr = instrs[0]
            debug_function_name = instr.function.name
            assert debug_function_name in self.__optimized_function_mapping, "Debug function not found"
            o3_function = self.__optimized_function_mapping[debug_function_name]
            m_name = o3_function.name
            assert m_name in ModuleInfo.modules
            state_info.module = ModuleInfo.modules[m_name]

    def __get_state_related_instr(self, module_name, state_id):
        # based on locations annotated in the state report. Notice that the location information is also messed up
        # due to function inlining
        instructions = ModuleInfo.modules[module_name].state_infos[state_id].instructions
        res = []
        line_info = set()
        for _, debug in instructions:
            if debug is None:
                continue
            # decode filename and line
            filename, line_num = debug
            if filename in self.__loc_map and line_num in self.__loc_map[filename]:
                # we only need one instruction for that line
                entry = (filename, line_num)
                if entry in line_info:
                    continue
                line_info.add(entry)
                instr = self.__loc_map[filename][line_num][0]

                res.append(instr)

        return res

    def __compute_variable_mapping(self):
        # this is to deal with completely messed up symbol mapping in Vitis. In addition, the final optimized
        # bitcode does not contain valid debug information. reached out to Vitis team. waiting for any response.

        # we use the following algorithm
        # for each state, we go to the corresponding line (using debug bitcode), get the variable declaration
        # from the debug bitcode and then try to match it with the optimized build. If there is any match, we have
        # to look around IR to see the actual name of the signal. This can be accomplished via readout out the
        # variable usage
        for module_name, module in ModuleInfo.modules.items():
            for state_id, state_info in module.state_infos.items():
                instructions = self.__get_state_related_instr(module_name, state_id)
                for instr in instructions:
                    # due to the transformation, we may not find a direct matching instruction
                    # we use the alloc instruction, which remains regardless the optimization
                    alloc = instr.prev_alloc
                    while alloc is not None:
                        # notice that this is from the debug build!
                        # if the code is SSA-transformed, which I think it is, the allocation should be unique
                        if state_info.module is None:
                            break
                        o3_function = state_info.module.optimized_function
                        matched_instr = o3_function.find_matching_instr(alloc)
                        if matched_instr is not None:
                            # find one. need to find what's actually called in RTL,
                            # which is very tricky since Xilinx doesn't open-source their stuff
                            rtl_name = matched_instr.rtl_name
                            if rtl_name:
                                print(rtl_name)
                        alloc = alloc.prev_alloc


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("solution", type=str, help="Xilinx Vitis solution dir")
    parser.add_argument("-o", dest="output", type=str, help="Output symbol table name")
    args = parser.parse_args()
    return args


def main():
    args = get_args()
    solution = args.solution
    info = DesignInfo(solution)


if __name__ == "__main__":
    main()
