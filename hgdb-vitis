#!/usr/bin/env python3

import os
import argparse
import pathlib
import vitis
import re
from typing import List, Dict
import xml.etree.ElementTree as ElementTree


class StateInfo:
    def __init__(self, state_id: int):
        self.id = state_id
        self.instructions = []
        self.module = None


class ModuleInfo:
    modules: Dict[str, "ModuleInfo"] = {}

    def __init__(self, module_name):
        self.module_name = module_name

        self.function = None

        self.state_infos: Dict[int, StateInfo] = {}


class InstanceInfo:
    def __init__(self, module_name, instance_name):
        self.module_name = module_name
        self.instance_name = instance_name

        if module_name not in ModuleInfo.modules:
            ModuleInfo.modules[module_name] = ModuleInfo(module_name)
        self.module_info = ModuleInfo.modules[module_name]


class DesignInfo:
    def __init__(self, solution):
        self.__solution = solution
        self.__parse_design_xml()
        self.top_name = ""

    def __parse_design_xml(self):
        xml_files = list(pathlib.Path(self.__solution).rglob("*.design.xml"))
        assert len(xml_files) == 1, "Only one design allowed in the solution"
        xml_file = xml_files[0]
        # parse the xml file to build design hierarchy
        # also set the top name
        filename = os.path.basename(xml_file)
        self.top_name = filename.replace(".design.xml", "")
        tree = ElementTree.parse(xml_file)
        root = tree.getroot()
        top_module = root.find("./RTLDesignHierarchy/TopModule")
        top_module_name = top_module.find("ModuleName").text
        assert top_module_name == self.top_name, "Design database files corrupted"
        # recursively figure out the design hierarchy
        self.design_hierarchy: Dict[str, List[InstanceInfo]] = {}
        # create top module
        ModuleInfo.modules[top_module_name] = ModuleInfo(top_module_name)
        self.__build_instance_hierarchy(top_module_name, top_module)
        self.__parse_llvm_bc()
        self.__parse_state_transition(self.top_name)
        self.__compute_variable_mapping()

    def __build_instance_hierarchy(self, parent_name, node):
        inst_list = node.find("InstancesList")
        self.design_hierarchy[parent_name] = []
        if inst_list is None:
            return
        for child in inst_list.findall("Instance"):
            inst_name = child.find("InstName").text
            module_name = child.find("ModuleName").text
            self.design_hierarchy[parent_name].append(InstanceInfo(module_name, inst_name))
            # recursive call
            self.__build_instance_hierarchy(module_name, child)

    def __parse_llvm_bc(self):
        # find the nice build with all the debug information
        o3_filename = os.path.join(self.__solution, ".autopilot", "db", "a.o.3.bc")
        assert os.path.exists(o3_filename), "Design bitcode not found"
        self.__o3_bc = vitis.parse_llvm_bitcode(o3_filename)

        # read out the debug build and figure out the call graph
        top_function = self.__o3_bc.get_function(self.top_name)
        assert top_function is not None, "Unable to locate top function in LLVM bitcode"
        function_names = top_function.get_contained_functions()
        # only interested in the functions created from top, which has its name prefixed
        function_names = [name for name in function_names if self.top_name in name]
        # need to compute the demangled name, which is the instance name
        for name in function_names:
            func = self.__o3_bc.get_function(name)
            assert func is not None, "Cannot find function " + name
            module_name = func.demangled_name
            assert module_name in ModuleInfo.modules
            ModuleInfo.modules[module_name].function = func
        ModuleInfo.modules[self.top_name].function = top_function

    def __parse_state_transition(self, module_name):
        # we need to parse state transition for every module since they are independent

        # recursively parse the state transition
        instances = self.design_hierarchy[module_name]
        for inst in instances:
            m_name = inst.module_name
            # recursively parse it
            self.__parse_state_transition(m_name)

        module_state_info = ModuleInfo.modules[module_name].state_infos
        rpt_path = os.path.join(self.__solution, ".autopilot", "db", module_name + ".verbose.rpt")
        assert os.path.exists(rpt_path), "Unable to find top verbose report"
        with open(rpt_path, "r") as f:
            rpt_lines = f.readlines()
        for i, line in enumerate(rpt_lines):
            if line.strip() == "* FSM state operations:":
                rpt_lines = rpt_lines[i + 1:]
                break
        for i, line in enumerate(rpt_lines):
            line = line.strip()
            if line and line[0] == "=":
                rpt_lines = rpt_lines[:i]
                break
        current_state = None
        state_num_re = re.compile(r"State(?P<id>\s\d+)")
        state_instr_re = re.compile(
            r"ST_\d+\s+:\s+[\w\s\[\]()/\.]+--->\s+\"(?P<instr>[\w%_\s=@\.,]+)\"\s+(\[(?P<debug>.*)])?\s+--->")
        for line in rpt_lines:
            m = state_num_re.search(line)
            if m is not None:
                state_id = m.group("id")
                if state_id:
                    state_id = int(state_id)
                    current_state = StateInfo(state_id)
                    module_state_info[state_id] = current_state
                    continue
            else:
                m = state_instr_re.search(line)
                if m is not None:
                    instr = m.group("instr")
                    debug = m.group("debug")
                    if debug is not None:
                        line_idx = debug.rindex(":")
                        filename = debug[:line_idx]
                        line_num = int(debug[line_idx + 1:])
                        debug = (filename, line_num)
                    current_state.instructions.append((instr, debug))

        # match state with module
        for state_id, state_info in module_state_info.items():
            state_info.module = ModuleInfo.modules[module_name]

    @staticmethod
    def __get_state_related_instr(module_name, function, state_id):
        # based on locations annotated in the state report. Notice that the location information is also messed up
        # due to function inlining
        module = ModuleInfo.modules[module_name]
        instructions = module.state_infos[state_id].instructions
        loc_map = function.get_instr_loc()
        res = []
        line_info = set()
        for _, debug in instructions:
            if debug is None:
                continue
            # decode filename and line
            filename, line_num = debug
            if filename in loc_map and line_num in loc_map[filename]:
                # we only need one instruction for that line
                entry = (filename, line_num)
                if entry in line_info:
                    continue
                line_info.add(entry)
                instr = loc_map[filename][line_num][0]

                res.append(instr)

        return res

    def __compute_variable_mapping(self):
        context = vitis.Context()
        for module_name, module in ModuleInfo.modules.items():
            function = module.function
            scope = function.get_debug_scope(context)
            print(scope.serialize())


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("solution", type=str, help="Xilinx Vitis solution dir")
    parser.add_argument("-o", dest="output", type=str, help="Output symbol table name")
    args = parser.parse_args()
    return args


def main():
    args = get_args()
    solution = args.solution
    info = DesignInfo(solution)


if __name__ == "__main__":
    main()
