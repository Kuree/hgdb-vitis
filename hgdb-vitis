#!/usr/bin/env python3

import os
import argparse
import pathlib
import vitis
import vitis0
import re
import xml.etree.ElementTree as ElementTree


class DesignInfo:
    def __init__(self, solution):
        self.__solution = solution
        self.__parse_design_xml()
        self.__parse_llvm_bc()
        self.__parse_state_transition(self.top_name)
        self.__parse_signal_names(self.top_name)
        self.__merge_module_states(self.top_name)
        self.__parse_debug_bc()

    def __parse_design_xml(self):
        xml_files = list(pathlib.Path(self.__solution).rglob("*.design.xml"))
        assert len(xml_files) == 1, "Only one design allowed in the solution"
        xml_file = xml_files[0]
        # parse the xml file to build design hierarchy
        # also set the top name
        filename = os.path.basename(xml_file)
        self.top_name = filename.replace(".design.xml", "")
        tree = ElementTree.parse(xml_file)
        root = tree.getroot()
        top_module = root.find("./RTLDesignHierarchy/TopModule")
        top_module_name = top_module.find("ModuleName").text
        assert top_module_name == self.top_name, "Design database files corrupted"
        self.top_module = vitis.ModuleInfo(top_module_name)
        # create top module
        vitis.set_module(top_module_name, self.top_module)
        self.__build_instance_hierarchy(top_module_name, top_module)

    def __parse_debug_bc(self):
        g_filename = os.path.join(self.__solution, ".autopilot", "db", self.top_name + ".bc")
        assert os.path.exists(g_filename), "Debug bitcode not found at " + g_filename
        self.scope_info = vitis0.get_function_scopes(g_filename)

    def __build_instance_hierarchy(self, parent_name, node):
        inst_list = node.find("InstancesList")
        if inst_list is None:
            return
        for child in inst_list.findall("Instance"):
            inst_name = child.find("InstName").text
            module_name = child.find("ModuleName").text
            mod = vitis.get_module(parent_name)
            mod.add_instance(module_name, inst_name)
            # recursive call
            self.__build_instance_hierarchy(module_name, child)

    def __parse_llvm_bc(self):
        # find the nice build with all the debug information
        o3_filename = os.path.join(self.__solution, ".autopilot", "db", "a.o.3.bc")
        assert os.path.exists(o3_filename), "Design bitcode not found"
        self.__o3_bc = vitis.parse_llvm_bitcode(o3_filename)

        # read out the debug build and figure out the call graph
        top_function = self.__o3_bc.get_function(self.top_name)
        assert top_function is not None, "Unable to locate top function in LLVM bitcode"
        function_names = top_function.get_contained_functions()
        # only interested in the functions created from top, which has its name prefixed
        function_names = [name for name in function_names if self.top_name in name]
        # need to compute the demangled name, which is the instance name
        for name in function_names:
            func = self.__o3_bc.get_function(name)
            assert func is not None, "Cannot find function " + name
            module_name = func.demangled_name
            assert vitis.has_module(module_name)
            vitis.get_module(module_name).function = func
        vitis.get_module(self.top_name).function = top_function

    def __get_report_lines(self, module_name):
        rpt_path = os.path.join(self.__solution, ".autopilot", "db", module_name + ".verbose.rpt")
        assert os.path.exists(rpt_path), "Unable to find verbose report " + rpt_path
        with open(rpt_path, "r") as f:
            rpt_lines = f.readlines()
        return rpt_lines

    def __parse_signal_names(self, module_name):
        # this is similar to the state transition since they're in the same file
        instances = vitis.get_module(module_name).instances
        for m in instances.values():
            # recursively parse it
            self.__parse_signal_names(m.module_name)

        module_signals = {}
        rpt_lines = self.__get_report_lines(module_name)
        register_mode = 0
        for line in rpt_lines:
            line = line.strip()
            if register_mode == 0:
                if line == "* Register:":
                    register_mode += 1
            elif register_mode <= 3:
                register_mode += 1
            elif register_mode == 4:
                if line[0] == '+':
                    # we're done
                    break
                tokens = list(filter(lambda x: x, line.split("|")))
                assert len(tokens) == 5, "Invalid register line " + line
                name = tokens[0].strip()
                width = int(tokens[3].strip())
                signal = vitis.SignalInfo(name, width)
                module_signals[name] = signal

        vitis.get_module(module_name).signals = module_signals

    def __parse_state_transition(self, module_name):
        # we need to parse state transition for every module since they are independent

        # recursively parse the state transition
        instances = vitis.get_module(module_name).instances
        for m in instances.values():
            # recursively parse it
            self.__parse_state_transition(m.module_name)

        module_state_info = {}
        rpt_lines = self.__get_report_lines(module_name)
        for i, line in enumerate(rpt_lines):
            if line.strip() == "* FSM state operations:":
                rpt_lines = rpt_lines[i + 1:]
                break
        for i, line in enumerate(rpt_lines):
            line = line.strip()
            if line and line[0] == "=":
                rpt_lines = rpt_lines[:i]
                break
        current_state = None
        state_num_re = re.compile(r"State(?P<id>\s\d+)")
        state_instr_re = re.compile(
            r"ST_\d+\s+:\s+[\w\s\[\]()/\.]+--->\s+\"(?P<instr>[\w%_\s=@\.,]+)\"\s+(\[(?P<debug>.*)])?\s+--->")
        for line in rpt_lines:
            m = state_num_re.search(line)
            if m is not None:
                state_id = m.group("id")
                if state_id:
                    state_id = int(state_id)
                    current_state = vitis.StateInfo(state_id)
                    module_state_info[state_id] = current_state
                    continue
            else:
                m = state_instr_re.search(line)
                if m is not None:
                    instr = m.group("instr")
                    debug = m.group("debug")
                    if debug is not None:
                        line_idx = debug.rindex(":")
                        filename = debug[:line_idx]
                        line_num = int(debug[line_idx + 1:])
                        current_state.add_instr(instr, filename, line_num)
                    else:
                        current_state.add_instr(instr)

        vitis.get_module(module_name).state_infos = module_state_info

    def __merge_module_states(self, module_name):
        instances = vitis.get_module(module_name).instances
        for m in instances.values():
            self.__merge_module_states(m.module_name)

        signals = vitis.get_module(module_name).signals
        info = vitis.get_module(module_name).state_infos
        vitis.get_module(module_name).state_infos = vitis.merge_states(info, signals, module_name)

    @staticmethod
    def __get_state_related_instr(module_name, function, state_id):
        # based on locations annotated in the state report. Notice that the location information is also messed up
        # due to function inlining
        module = vitis.get_module(module_name)
        instructions = module.state_infos[state_id].instructions
        loc_map = function.get_instr_loc()
        res = []
        line_info = set()
        for _, debug in instructions:
            if debug is None:
                continue
            # decode filename and line
            filename, line_num = debug
            if filename in loc_map and line_num in loc_map[filename]:
                # we only need one instruction for that line
                entry = (filename, line_num)
                if entry in line_info:
                    continue
                line_info.add(entry)
                instr = loc_map[filename][line_num][0]

                res.append(instr)

        return res

    def dump_symbol_table(self, output, remap):
        context = vitis.Context()
        options = vitis.SerializationOptions()
        for b, a in remap.items():
            options.add_mapping(b, a)

        tables = {}
        module_scopes = {}
        module_names = vitis.module_names()
        for module_name in module_names:
            module = vitis.get_module(module_name)
            function = module.function
            scope = function.get_debug_scope(context)
            scope.bind_state(module)
            module_scopes[module_name] = scope

        module_scopes = vitis.reorganize_scopes(self.__o3_bc, self.scope_info, module_scopes)

        for module_name, scope in module_scopes.items():
            tables[module_name] = scope.serialize(options)

        res = "{\"generator\":\"vitis\",\"table\":["
        count = 1
        for module_name, s in tables.items():
            res += "{"
            res += "\"type\":\"module\",\"name\":\"" + module_name + "\",\"scope\":[" + s + "],\"instances\":["
            # generate instances
            instances = vitis.get_module(module_name).instances
            i = 0
            for inst_name, inst in instances.items():
                res += "{\"name\":\"" + inst_name + "\","
                res += "\"module\":\"" + inst.module_name + "\"}"
                if i != ((len(instances)) - 1):
                    res += ","
                i += 1
            # no variables for now since most of them are C functions
            res += "],\"variables\":[]}"
            if count != len(tables):
                res += ","
            count += 1
        res += "],\"top\":\"" + self.top_name + "\""
        # clock attribute
        res += ",\"attributes\":[{\"name\":\"clock\",\"value\":\"" + self.top_name + ".ap_clk\"}]"
        res += "}"

        if output:
            with open(output, "w+") as f:
                f.write(res)


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("solution", type=str, help="Xilinx Vitis solution dir")
    parser.add_argument("-o", dest="output", type=str, help="Output symbol table name")
    parser.add_argument("-r", "--remap", dest="remap")
    args = parser.parse_args()
    return args


def strip_end(string, c):
    while string and string[-1] == c:
        string = string[:-1]
    return string


def preprocess_remap(remap):
    if remap is None:
        return {}
    else:
        groups = remap.split(";")
        res = {}
        for m in groups:
            g = m.split(":")
            assert len(g) == 2, "Invalid remap option " + remap
            before_name = g[0]
            after_name = g[1]
            before_name = strip_end(before_name, '/')
            after_name = strip_end(after_name, '/')
            res[before_name] = after_name
        return res


def main():
    args = get_args()
    solution = args.solution
    info = DesignInfo(solution)
    info.dump_symbol_table(args.output, preprocess_remap(args.remap))


if __name__ == "__main__":
    main()
