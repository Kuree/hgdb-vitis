#!/usr/bin/env python3

import os
import argparse
import pathlib
import llvmlite.binding
import vitis
import xml.etree.ElementTree as ElementTree


class DesignInfo:
    def __init__(self, solution):
        self.__solution = solution
        self.__parse_design_xml()
        self.top_name = ""

    def __parse_design_xml(self):
        xml_files = list(pathlib.Path(self.__solution).rglob("*.design.xml"))
        assert len(xml_files) == 1, "Only one design allowed in the solution"
        xml_file = xml_files[0]
        # parse the xml file to build design hierarchy
        # also set the top name
        filename = os.path.basename(xml_file)
        self.top_name = filename.replace(".design.xml", "")
        tree = ElementTree.parse(xml_file)
        root = tree.getroot()
        top_module = root.find("./RTLDesignHierarchy/TopModule")
        top_module_name = top_module.find("ModuleName").text
        assert top_module_name == self.top_name, "Design database files corrupted"
        # recursively figure out the design hierarchy
        self.design_hierarchy = {}
        self.__build_instance_hierarchy(top_module_name, top_module)
        self.__parse_llvm_bc()

    def __build_instance_hierarchy(self, parent_name, node):
        inst_list = node.find("InstancesList")
        if inst_list is None:
            return
        self.design_hierarchy[parent_name] = []
        for child in inst_list.findall("Instance"):
            inst_name = child.find("InstName").text
            module_name = child.find("ModuleName").text
            self.design_hierarchy[parent_name].append((module_name, inst_name))
            # recursive call
            self.__build_instance_hierarchy(module_name, child)

    def __parse_llvm_bc(self):
        # find the nice build with all the debug information
        g_bc_filename = os.path.join(self.__solution, ".autopilot", "db", self.top_name + ".bc")
        o3_filename = os.path.join(self.__solution, ".autopilot", "db", "a.o.3.bc")
        assert os.path.exists(g_bc_filename) and os.path.exists(o3_filename), "Design bitcode not found"
        with open(g_bc_filename, "rb") as f:
            bc = f.read()
            g_bc = llvmlite.binding.parse_bitcode(bc)
        g_bc = vitis.parse_llvm_bitcode(g_bc_filename)
        o3_bc = vitis.parse_llvm_bitcode(o3_filename)

        # read out the debug build and figure out the call graph

    def __parse_state_transition(self):
        # we only need to parse the state transition for the top module
        # since everything is statically scheduled
        pass


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("solution", type=str, help="Xilinx Vitis solution dir")
    parser.add_argument("-o", dest="output", type=str, help="Output symbol table name")
    args = parser.parse_args()
    return args


def main():
    args = get_args()
    solution = args.solution
    info = DesignInfo(solution)


if __name__ == "__main__":
    main()
