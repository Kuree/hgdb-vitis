#!/usr/bin/env python3

import os
import argparse
import pathlib
import vitis
import re
import xml.etree.ElementTree as ElementTree


class StateInfo:
    def __init__(self, state_id: int):
        self.id = state_id
        self.instructions = []


class DesignInfo:
    def __init__(self, solution):
        self.__solution = solution
        self.__parse_design_xml()
        self.top_name = ""

    def __parse_design_xml(self):
        xml_files = list(pathlib.Path(self.__solution).rglob("*.design.xml"))
        assert len(xml_files) == 1, "Only one design allowed in the solution"
        xml_file = xml_files[0]
        # parse the xml file to build design hierarchy
        # also set the top name
        filename = os.path.basename(xml_file)
        self.top_name = filename.replace(".design.xml", "")
        tree = ElementTree.parse(xml_file)
        root = tree.getroot()
        top_module = root.find("./RTLDesignHierarchy/TopModule")
        top_module_name = top_module.find("ModuleName").text
        assert top_module_name == self.top_name, "Design database files corrupted"
        # recursively figure out the design hierarchy
        self.design_hierarchy = {}
        self.__build_instance_hierarchy(top_module_name, top_module)
        self.__parse_llvm_bc()
        self.__parse_state_transition()

    def __build_instance_hierarchy(self, parent_name, node):
        inst_list = node.find("InstancesList")
        if inst_list is None:
            return
        self.design_hierarchy[parent_name] = []
        for child in inst_list.findall("Instance"):
            inst_name = child.find("InstName").text
            module_name = child.find("ModuleName").text
            self.design_hierarchy[parent_name].append((module_name, inst_name))
            # recursive call
            self.__build_instance_hierarchy(module_name, child)

    def __parse_llvm_bc(self):
        # find the nice build with all the debug information
        g_bc_filename = os.path.join(self.__solution, ".autopilot", "db", self.top_name + ".bc")
        o3_filename = os.path.join(self.__solution, ".autopilot", "db", "a.o.3.bc")
        assert os.path.exists(g_bc_filename) and os.path.exists(o3_filename), "Design bitcode not found"
        self.__g_bc = vitis.parse_llvm_bitcode(g_bc_filename)
        self.__o3_bc = vitis.parse_llvm_bitcode(o3_filename)

        # read out the debug build and figure out the call graph
        top_function = self.__g_bc.get_function(self.top_name)
        assert top_function is not None, "Unable to locate top function in LLVM bitcode"
        # we need to index locations to function instruction so that once we look at the state transition
        # we know what function to look at
        self.__loc_map = top_function.get_instr_loc()

    def __parse_state_transition(self):
        # we only need to parse the state transition for the top module
        # since everything is statically scheduled
        rpt_path = os.path.join(self.__solution, ".autopilot", "db", self.top_name + ".verbose.rpt")
        assert os.path.exists(rpt_path), "Unable to find top verbose report"
        with open(rpt_path, "r") as f:
            rpt_lines = f.readlines()
        self.state_info = {}
        for i, line in enumerate(rpt_lines):
            if line.strip() == "* FSM state operations:":
                rpt_lines = rpt_lines[i + 1:]
                break
        for i, line in enumerate(rpt_lines):
            line = line.strip()
            if line and line[0] == "=":
                rpt_lines = rpt_lines[:i]
                break
        current_state = None
        state_num_re = re.compile(r"State(?P<id>\s\d+)")
        state_instr_re = re.compile(
            r"ST_\d+\s+:\s+[\w\s\[\]()/\.]+--->\s+\"(?P<instr>[\w%_\s=@\.,]+)\"\s+(\[(?P<debug>.*)])?\s+--->")
        for line in rpt_lines:
            m = state_num_re.search(line)
            if m is not None:
                state_id = m.group("id")
                if state_id:
                    state_id = int(state_id)
                    current_state = StateInfo(state_id)
                    self.state_info[state_id] = current_state
                    continue
            else:
                m = state_instr_re.search(line)
                if m is not None:
                    instr = m.group("instr")
                    debug = m.group("debug")
                    current_state.instructions.append((instr, debug))

    def __get_state_related_instr(self, state_id):
        # based on locations annotated in the state report. Notice that the location information is also messed up
        # due to function inlining
        instructions = self.state_info[state_id].instructions
        res = []
        line_info = set()
        for instr, debug in instructions:
            if debug is None:
                continue
            # decode filename and line
            line_idx = debug.rindex(":")
            filename = debug[:line_idx]
            line_num = int(debug[line_idx + 1:])

            if filename in self.__loc_map and line_num in self.__loc_map[filename]:
                # we only need one instruction for that line
                entry = (filename, line_num)
                if entry in line_info:
                    continue
                line_info.add(entry)
                instr = self.__loc_map[filename][line_num][0]

                res.append(instr)

        return res

    def __compute_variable_mapping(self):
        # this is to deal with completely messed up symbol mapping in Vitis. In addition, the final optimized
        # bitcode does not contain valid debug information. reached out to Vitis team. waiting for any response.

        # we use the following algorithm
        # for each state, we go to the corresponding line (using debug bitcode), get the variable declaration
        # from the debug bitcode and then try to match it with the optimized build. If there is any match, we have
        # to look around IR to see the actual name of the signal. This can be accomplished via readout out the
        # variable usage

        pass


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("solution", type=str, help="Xilinx Vitis solution dir")
    parser.add_argument("-o", dest="output", type=str, help="Output symbol table name")
    args = parser.parse_args()
    return args


def main():
    args = get_args()
    solution = args.solution
    info = DesignInfo(solution)


if __name__ == "__main__":
    main()
